%!TEX root = /Users/gs/projects/rforge/sintro/pkg/sprof/work/vignettes/sprofiling.tex
% -*- mode: noweb; noweb-default-code-mode: R-mode; -*-
%$HeadURL$x


% options(width=72); setwd("/Users/gs/projects/rforge/sintro/pkg/sprof/work/vignettes/" )
% Sweave(file= "../../vignettes/sprofiling.Rnw", output="sprofiling.tex", keep.source=TRUE)
% debug=TRUE, eps=FALSE, pdf=TRUE, keep.source=TRUE
%
%global flags for conditional builds
%:flags
\def\private{true}% comment out for public version
\def\solutions{true}% comment out to hide solutions
\def\usehyperref{true}% comment out to skip hyperref

\documentclass[utf8]{amsart}
\usepackage[utf8]{inputenc}
%\usepackage[applemac]{inputenc}
\usepackage[english]{babel} %ngerman
%\usepackage[makeindex]{splitidx}
%\newindex[R functions by topic]{rtop}
%\newindex[R functions]{rfun}
\usepackage{fancyref}
\usepackage{cleveref}

\usepackage{gssda} %! add code, codearg, 
\usepackage{SIntro}
\usepackage{url} %! bubble up to gssda
\setkeys{Gin}{width=1.0\textwidth}

\setcounter{tocdepth}{3}
\setlength{\parskip}{6pt}
\setlength{\parindent}{0pt}

\newcommand{\R}{{\normalfont\textsf{R}}{}}
\newcommand\ircode[1]{\textsl{\texttt{#1}}}
\newcommand\ircodex[1]{\textsl{\texttt{#1}}\index{#1@\texttt{#1}|textit}}
%??2
%\newcommand{\keyword}[2]{\index[rtop]{\ Topic{\large\ \textbf{#1}}!#2@\texttt{#2}}}
\newcommand{\keyword}[2]{\index{\ Topic{\large\ \textbf{#1}}!#2@\texttt{#2}}}
%\newcommand\irfunx[2]{\keyword{#1}{#2}\ircode{#2()}\index[rfun]{#2@\texttt{#2}|textit}}% fun() & index, like \Link
\newcommand\irfunx[2]{\keyword{#1}{#2}\ircode{#2()}\index{#2@\texttt{#2}|textit}}

%	\newcommand{\keyword}[2]{\sindex[rtop]{\ Topic{\large\ \textbf{#1}}!#2@\texttt{#2}}}
%	\newcommand\irfunx[2]{\keyword{#1}{#2}\ircode{#2()}\sindex[rfun]{#2@\texttt{#2}|textit}}% fun() & index, like \Link
%	\newcommand\ircodex[1]{\textsl{\texttt{#1}}\sindex{#1@\texttt{#1}|textit}}
% \newcommand\ircodex[1]{\textsl{\texttt{#1}}\sindex{#1@\texttt{#1}|textit}}

%??1
\newcommand\irarg[1]{\small{$\langle$\verb+#1+$\rangle$}}% should be 
%??3

\title{R profiling and optimisation}
\author{G\"unther Sawitzki}

\address{\noindent G\"unther Sawitzki\newline
\indent StatLab Heidelberg\newline
\indent Im Neuenheimer Feld 294\newline
\indent D 69120 Heidelberg\newline}%\\\bigskip\bigskip\bigskip\bigskip\bigskip \\ %
\thanks{\emph{An \R{} vignette for package sprof. }\ifx\private\undefined%
\typeout{ommitting private stuff ********}
\else
\emph{Private Version}\\
\fi
}
\email{gs@statlab.uni-heidelberg.de}
\urladdr{http://sintro.r-forge.r-project.org/}
\keywords{R programming, profiling, optimisation, R program language}

\date{
%June 1992, published as technical report \cite{gs92shrth}.\\
%For quotation, please use the general reference \cite{gs94oned}.\\
%Revised: August 2007\\
%Typeset, with minor revisions: \today}      % Activate to display a given date or no date
Typeset: \today}                                           % Activate to display a given date or no date

%\usepackage{gssda}
%\usepackage{gsSweave}%\usepackage{SIntro}%\usepackage{Sweave}
%\setkeys{Gin}{width=1.0\textwidth}
%:Sweave

\newcommand\Stt[1]{\textsl{\texttt{#1}}}

%\usepackage{a4wide}

\makeindex
\listfiles
\begin{document}


\maketitle
\section*{Pending changes}
\begin{itemize}
\item {Control information may be included as special stack in raw format.}
\item {A list of profiles may become default. Only one profiling interval value per profile.}
\item {Nodes may implemented as \ircode{factor}.}
\end{itemize}
\bigskip

{
\setlength{\parskip}{0pt}
\tableofcontents
}
\section*{Profiling facilities in \R{}}
\R{} provides the basic instruments for profiling, both for time based samplers as for 
event based instrumentation. However this source of information seems to be rarely
used.

Maybe the supporting tools are not adequate. The summaries provided by \R{}  reduce the 
information beyond necessity. Additional packages are available, but these are not
sufficiently action oriented.

With package \ircode{sprof} we want to give a data representation that keeps the full
profile information. Tools to answer common questions are provided. The data structure 
should make it easy to extend the tools as required.

The package is currently distributed at r-forge as part of the \ircode{sintro} material.

\smallskip
To install this package directly within \R{}, type \\
 {\small   \ircode{install.packages("sprof",repos="http://r-forge.r-project.org")}}

\smallskip
To install the recent package from source directly within \R{}, type\\
    {\small   \ircode{install.packages("sprof",repos="http://r-forge.r-project.org",type="source")}}

\section*{\LaTeX{}  Layout Tools and Utilities}

%Tests for TeX
%
%*fref:
%
%\fref{subs:Rprof}
%
%\fref{tab:prSRREbs}
%
%*vref:
%
%subs: \vref{subs:Rprof}
%
%tab: \vref{tab:prSRREbs}
%
%*cref:
%
%subs: \cref{subs:Rprof}
%
%tab: \cref{tab:prSRREbs}

\smallskip
Print parameters used here:
<<>>=
options(width = 72)
options(digits = 6)
@

We want immediate warnings, if necesary. Set to level 2 to handle warnings as error.
<<>>=
message("switching  options(warn=1) -- immediate warning on")
options(warn=1)

@
%This is just a hack to get a nicer output from args:
%<<>>=
%prargs <- function(x){ str(args(x))}
For larger tabels and data frames, we use a cludge to avoid long outputs.
<<>>=
xcutdata.frame <- function(df,  cut, margin){
#! keep3, to add: margin top - random center - margin bottom
	if (!is.data.frame(df)) return(df)
	nrow <- nrow(df)
	# cut a range if it is not empty. 
	# Quiet noop else. 
	# Does not cut single lines.
	 cutrng <- function(cutfrom,cutto){
	 	if (cutfrom<cutto){
		df[cutfrom,] <- NA
		if (!is.null(rownames(df))) rownames(df)[cutfrom] <- "< cut >"
		if (!is.null(df$name)) df$name[cutfrom] <- ""
		
		cutfrom <- cutfrom+1
		df[-(cutfrom:cutto),]
		}#if
	}
	if (!missing(cut))  {df <- cutrng(cut[1],cut[2]); return(df)}
	if (!missing(margin))  {
		if (length(margin)==1) margin <-  c(margin,margin)
	cut <- c(margin[1]+1,nrow-margin[2])
	df <-cutrng(cut[1],cut[2]); 
	return(df)}
#	if (!missing(keep3))  { cut <- c(keep3[1]+1, keep3[1]+1, 
#		nrow-keep3[3]-1,nrow-keep3[3]-1)
#	if (cut[3]-cut[4] > keep3[2]+2){delta<-(cut[3]-cut[2]) div 2
#	cut[3]<-0
#	browser()
#	} else df <- cutrng(cut[1],cut[4])
#	cutrng(cut[1],cut[4]) return(df)}
}

@
We use the \R{} function \ircode{xtable()} for output and \LaTeX \ \ircode{longtable}. A convenient wrapper to use this in out \ircode{Sweave} source is:
<<>>= 
library(xtable)
prxt <- function (x, digits=3, 	caption=NULL, 
	label=NULL, ...)  {
	margin <- 10
	if (nrow(x)> 2*margin+3) x <-xcutdata.frame(x, margin=margin)
	print(
		xtable(x, digits=digits, caption=caption, 
				label=label, ...), 
		floating=FALSE, 
		tabular.environment="longtable", 
		caption.placement="top",
		NA.string="\\vdots")
	}
@
This is to be used with
\verb+<<print=FALSE, results =tex, label=tab:prxx>>=+

@
\section{Profiling}
The basic information provided by all profilers in is a protocol of sampled stacks. 
For each recorded event, the protocol has one record, such as a line with a text string showing the sampled  stack.

We use profiles to provide hints on the dynamic behaviour of programs. Most often, this is used to improve or even optimise programs. Sometimes, it is even used to understand some algorithm.

Profiles represent the program flow, which is considered to be laid out by the control structure of a program. The control structure is represented by the control graph, and this leads to the common approach to (re)construct the control graph, map the profile to this graph, and used graph based methods for further analysis. The prime example for this strategy is the GNU profiler \ircode{gprof} (see \url{http://sourceware.org/binutils/docs/gprof/}) which is used as master plan for many common profilers.

\medskip
It is only half of the truth that the control graph can serve as a base for the profiled stacks. In \R{}, we have some peculiarities.

\begin{description}
\item[lazy evaluation] Arguments to functions can passed as promises. These are only evaluated when needed, which may be at a later time, and may then lead to insertions in the stack. So we may have information resulting from the data flow, interspersed with the control flow.
\item[memory management] Allocation of memory, and garbage collection, may interfere and leave their traces in the stack. While allocation is closely related to the visible control flow, garbage collection is a collective effect largely out of control of the code to execute.
\item[primitives] Internal functions may escape the usual stack conventions and execute without leaving any identifiable trace on the stack.
\item[control structures] In \R{}, many control structures are implemented as function.
Most notably, the \irfunx{misc}{apply} family appear as function calls and lead to cliques in the graph representation that do not correspond to relevnat structures. Since these functions are well know, they can have a special treatment.
\end{description}

So while the stack follows an overall well known dynamics, in \R{} there are exceptions from regularity.
\medskip
The general approach, by \irfunx{misc}{summaryRprof} and others, is to reduce the profile to node information, or two consider single transitions.

\medskip
We take a different approach.  We take the stacks, as recorded in the profiles as our basic information unit.  From this, we ask: what are the actions we need to answer our questions?
Representation in graphs may come later, if they can help.

If the stacks would come from the control flow only, we could make use of the sequential 
nature of stacks. But since we have to live with the \R{} specific interferences, we stay with the raw stacks.
<<>>=
options(error = recover)
library(sprof)
@

In this presentation, we will use a small list of examples Since \ircode{Rprof} is not implemented on all systems, and since the profiles tend to get very large, we use some prepared examples that are frozen in this vignette and not included in the distribution, but all the code to generate the examples is provided.


\subsection{Simple regression example}
\label{subs:RegressionExpl}
\label{subs:Rprof}
<<label=RegressionExpl>>=
n <- 10000
x <- runif(n)
err <- rnorm(n)
y <- 2+ 3 * x + err
reg0data <- data.frame(x=x, y=y, err=err)
rm(x,y,err)

@
We will use this example to illustrate the basics. Of course the immediate questions are the variance between varying samples, and the influence of the sample size $n$. We keep everything fixed, so the only issue for now is the computational performance under strict iid conditions.

Still we have parameters to choose. We can determine the profiling granularity by setting the timing interval, and we can use repeated measurements to increase precision below the timing interval.

The timing interval should depend on the clock speed. Using for example 1ms amounts to some 1000 steps on a current CPU, per kernel.

If we use repeated samples, the usual rules of statistics applies. So taking $100$ runs and taking the mean reduces the standard deviation by a factor $1/10$.
%So with $simruns <- 100$, the mean 
%var mean = var n x / n^2

<<label=Rprof01>>=
profinterval <- 0.001
simruns <- 100

Rprof(filename="RprofsRegressionExpl.out", interval = profinterval)
for (i in 1:simruns) xxx<- summary(lm(y~x, data=reg0data))
Rprof(NULL)
@

We now have the profile data in a file \ircode{RprofsRegressionExpl.out}.
For this vignette, we use a frozen version \ircode{RprofsRegressionExpl01.out}.

\subsubsection{R basic}
The basic \R{} invites us to get a summary. 

<<>>=
sumRprofRegressionExpl <- summaryRprof("RprofsRegressionExpl01.out")
str(sumRprofRegressionExpl, vec.len=3)
@

The summary reduces the information contained in the profile to marginal statistics per node. This is provided in two data frames giving the same information, only in different order.

The file contains several spurious recordings: nodes that have been recorded only few times. It is worth noting these, but then they better be discarded. We use a time limit of 4ms, which given our sampling interval of 1ms means we require more than four observations.

<<print = FALSE, results = tex, label=tab:prSRREbs>>=
prxt(sumRprofRegressionExpl$by.self,
	caption="summaryRprof result: by.self as final stack entry, all records", 
	label="tab:prSRREbs")
@

<<print = FALSE, results = tex, label=tab:prSRREbt>>=
prxt(sumRprofRegressionExpl$by.total[sumRprofRegressionExpl$by.total$total.time>0.004,],
	caption="summaryRprof result: by.total, total time > 0.004s", 
	label="tab:prSRREbt")
@

\filledpagebreak
\subsubsection{Package sprof}
In contrast to the common \R{} packages, in our implementation we take a two step approach. First we read in the profile file to an internal representation. Analysis is done in later steps.

<<>>=
sprof01lm <- readRprof("RprofsRegressionExpl01.out")
sprof01 <- sprof01lm
@

We keep this example and use the copy \ircode{sprof01} of it extensively for illustration.
<<eval=FALSE>>=
save(sprof01lm, file="sprof01lm.RData")
@
To run the vignette with a different profile, replace \ircode{sprof01} by your example. You still have \ircode{sprof01lm} for reference.

Package \ircode{sprof} provides a function \irfunx{misc}{sampleRprof} to take a sample and create a profile on the fly, as in
<<eval=FALSE>>=
sprof01temp <- sampleRprof(runif(10000), runs=100)
@
The basic data structure consists of four data frames. The ircode{info} section collects global infromation from the input file, such as an identification strings and various global matrix. The \ircode{nodes} section inititally gives the same information marginal information as  \ircode{summaryRprof}. The \ircode{stacks} section puts the node information into their calling context as found in the input profile file. The \ircode{profiles} section gives the temporal context. It is implemented as a list, but conceptually it is a data frame. Implementing it as a list allows run length encoding of variables, which unfortunately is not allowed by \R{} in data frames.
<<>>=
str(sprof01, max.level=2, vec.len=3,nchar.max=40)
@
The nodes do not come in a specific order. Access via a permutation vector is preferred. Thisallows different views onthe same data set. For example, \vref{tab:prspbt} uses a permutation by total time, and a selection (compare to \vref{tab:prSRREbt}). The only difference is that we work on a ms base internally, whereas \R{} uses seconds as a base. \todo{introduce cpu clock cycle as a time base}
<< print = FALSE, results = tex, label=tab:prspbt>>=
nodes <- sprof01$nodes[order(sprof01$nodes$total.time, decreasing=TRUE),]
prxt(nodes[nodes$total.time>4,],
caption="splot result: by.total, total time > 0.004s", 
	label="tab:prspbt")
@
Common rearrangements as by total time and by self time are supplied by the display functions.
Plot, for example, currently gives a choice of four displays for nodes.
<<fig=TRUE, label=sREplotnodes01, width=12, height=12>>=
oldpar <- par(mfrow=c(2,2))
plot_nodes(sprof01)
par(oldpar)
@
We can add attributes to the plots. But we can also attributes to the nodes, and use these in the plots. The attribute \ircode{icol} is a special case. If present, it will be interpreted as an index to a colour table. For example, we can collect special well known functions in groups:

<<>>=
x_apply <- c("apply", "lapply", "vapply", "sapply")
x_as <- c("as.list", "as.data.frame", "as.list.data.frame",
	"as.character", "as.list.default","as.name")
@
(Extend as you need it) and then us as for example:
<<>>=
nodeclass <- rep("x_nn", sprof01$info$nrnodes)
nodeclass[sprof01$nodes$name %in% x_apply] <- "x_apply"
nodeclass[sprof01$nodes$name %in% x_as] <- "x_as"
@
or use assignments on the fly
<<>>=
nodeclass[sprof01$nodes$name %in% 
	c("eval",  "evalFunc",
		"try", "tryCatch", "tryCatchList", "trCatchOne",
		"doTryCatch")
		] <- "x_eval"
nodeclass[sprof01$nodes$name %in% 
	c("model.frame", "model.matrix.default","model.frame.default",
	 " model.response", "model.matrix", "model.response")
		] <- "x_model"
nodeclass[sprof01$nodes$name %in% 
	c("lm", "lm.fit", "summary.lm")
		] <- "x_lm"
@
% data.frame(sprof01$nodes$name,sprof01$nodes$icol)
<<>>=
sprof01$nodes$icol <-as.factor(nodeclass)
@
adds a sticky colour attribute. To interpret, you should choose your preferred colour platette, for example
<<>>=
col=c("red", "green", "blue", "yellow", "cyan", "magenta")
@
<<fig=TRUE, label=sREplotnodes01col, width=12, height=12>>=
oldpar <- par(mfrow=c(2,2))
plot_nodes(sprof01, col=c("red", "green", "blue", "yellow", "cyan", "magenta"))
par(oldpar)
@
You can break down the frequency by the classes you have define. But beware of Simpson's paradox. The information you thinkyou see may be strongly affected by your choices - what you see are reflections of conditional distributions. These may very different from the global picture.
<<fig=TRUE, label=sprof01coltab>>=
plot(table(sprof01$nodes$icol),  
	type="h", lwd=20,col=col, lend="square", ylab="count")
@
%wordcloud(words,freq,
%	scale=c(4,.5),min.freq=3,max.words=Inf,
%	random.order=TRUE, random.color=FALSE, 
%	rot.per=.1, 	
%	colors="black",ordered.colors=FALSE,
%	use.r.layout=FALSE,fixed.asp=TRUE, ...)
If package \ircode{wordcloud} is installed, a differend view is possible.
<<fig=TRUE, label=snodes01cloudcol, width=12, height=12>>=
nodescloud <- function(sprof,min.freq=3, col){
	wordcloud(sprof$nodes$name, freq = sprof$nodes$total.time,
		min.freq=min.freq, 
		random.order=FALSE,
		colors = col[sprof01$nodes$icol],
		ordered.colors=TRUE)
	}
	
nodescloud(sprof01, min.freq=5, 
		col=c("red", "green", "blue", "yellow", "cyan", "magenta"))
@
\section{A better grip on profile information}
\label{sec:sprof}

The basic information provided by all profilers in \R{} is a protocol of sampled stacks. The conventional approach is to break the information down to nodes and edges. The stacks provide more information than this. One way to access it is to use linking to pass information. 

To illustrate this, we encode the frequency of the nodes as colour. As a palette, we choose a heat map here. 
<<>>=
freqrank <- rank(sprof01$nodes$total.time, ties.method="random")
col <- heat.colors(length(freqrank))
@
Here is the node view using these choices:
<<fig=TRUE, label=sREplotnodes01freqcol, width=12, height=12>>=
sprof01$nodes$icol <- freqrank
oldpar <- par(mfrow=c(2,2))
plot_nodes(sprof01, col=col)
par(oldpar)

@
This is what we get for free on our three levels: node, stack, and profile.

<< label= shownodes>>=
shownodes <- function(sprof=sprof01) {
oldpar <- par(mfrow=c(1,3))
oldpar<- par(no.readonly = TRUE)
layout(matrix(c(1,2,3,3), 2, 2, byrow = TRUE))#colp <- rainbow(sprof$info$nrnodes)

#plot_nodes # 3
xnodes <- sprof$nodes
src <- sprof$info$src
mincount <- 5
nrnodes <- dim(xnodes)[1]
 totaltime <- sum(xnodes$self.time)
colp <- rainbow(nrnodes)
colp <- colp[order(xnodes$total.time,decreasing=TRUE)]
 xnodes$colp <- colp
xnodes <- xnodes[xnodes$total.time < totaltime,]
#browser()
if (mincount>0) xnodes <- xnodes[xnodes$total.time>=mincount,]
trimmed <- nrnodes-dim(xnodes)[1]
legnd <-function(trimmed=0, fulltime=0){
ltext <- paste(nrnodes,"nodes\n")
if (trimmed>0) ltext <- paste(ltext,trimmed," nodes with",mincount,"or less\n total counts omitted\n")
if (fulltime>0) ltext  <- paste(ltext,fulltime,"permanent nodes  omitted\n")
legend("topright", legend=ltext, bty="n") 
}

totaltime <- sum(xnodes$self.time)
fulltime <- dim(xnodes)[1]
 xnodes <- xnodes[xnodes$total.time < totaltime,]
 fulltime <- fulltime - dim(xnodes)[1]
ordertotal<- order(xnodes$total.time,decreasing=TRUE);

barplot(xnodes[ordertotal,]$total.time, 
main="Nodes: total time in stack",
names.arg = xnodes[ordertotal,]$name, sub=src, ylab="count", 
col=xnodes$colp);
legnd(trimmed=trimmed, fulltime=fulltime)

stacks_nodes <- list.as.matrix(sprof$stacks$nodes)
#<<fig=TRUE, label=sREimgstacks>>=
image(x=1:ncol(stacks_nodes),y=1:nrow(stacks_nodes), 
t(stacks_nodes),xlab="stack", ylab="depth", main="nodes by stack")

profile_nodes <- profiles_matrix(sprof)
#<<fig=TRUE, label=sREimgprofiles>>=
image(x=1:ncol(profile_nodes),y=1:nrow(profile_nodes), 
t(profile_nodes),xlab="event", ylab="depth", main="nodes by event")

par(oldpar)
}
<<fig=TRUE, label= shownodes01, with=12, heigth=12>>=

shownodes(sprof01)

@
The obvious message is that if seen by stack level, there are different structures. Profiling usually takes place in a framework. So at the base of the stacks, we find entries that are (almost) persistent. Then usually we have some few steps where the algorithm splits, and then we have the finer details. These can be identified using information on the stack level, but of course theyare not visible on the node or edge level.

Not so often, but a frequent phenomenon is to have some ``burn in'' or ``fade out''. To identify this, we need to look at the profile level.

At a closer look, we may find stack patterns (maybe marked by specific nodes) that indicate administrative intervention and rather should be handled as aseparators between distinct profiles than as part of the general dynamics.

Stable framework effect can be detected automatically. ``burn in'' or ``fade out' may need a closer look, and special stacks need and individual inspection on low frequency stacks. 

Before starting additional inspection, the data better be trimmed. At this point, it is a decision whether to adapt the timing information, or keept the original information. Since this decision does affect the structural information, it is not critical. But analysis is easier if unused nodes are eliminated.
<<>>=
sprof02 <- sprof01
basetrim <- 13
sprof02$stacks$nodes <- sapply(sprof02$stacks$nodes, 
	function (x){if (length(x)> basetrim) x[-(1:basetrim)] })

<<fig=TRUE, label= sprof02shownodes, width=24, height=24>>=
shownodes(sprof02)
@
For a visual inspection, runs of the same node and level in the profile 
are easily perceived. For
an analytical inspection, we have to reconstruct the runs from the data. In stacks, runs are organized hierarchically. On the root level, runs are just ordinary runs. On the next levels, runs have to be defined given (within) the previous runs. So we need a recursive version of \ircode{rle}, applied to the profile information.
This gives a detailed information about the presence time of each node, by stack level.
<<>>=
profile_nodes <- profiles_matrix(sprof02)
profile_nodes_rle<- rrle(profile_nodes)
profile_nodes_rlet <- lapply(profile_nodes_rle, 
	function(x) table(x,dnn=c("count","node")) )
invisible(lapply(profile_nodes_rlet, 
function(x) print.table(x,zero.print = ".") ))
@
\todo{add current level}

\todo{generate a coplot representation}
\todo{add time per call information}
\subsection{The details}
For each recorded event, the protocol records one line with a text string showing the sampled  stack 
(in reverse order: most recent first). The stack lines may be preceded by header lines with event 
specific information. The protocol may be interspersed with control information, such as information about the timing interval used. 
%Examples of the protocol format used by the common profilers in in \ref{sec:formats} on page \pageref{sec:formats}.

We know that the structural information, static information as well as dynamic information, can be represented with the
help of a graph. For a static analysis, the graph representation may be the first choice. For a dynamic analysis, the stack information is our first information. A stack is a connected path in the program graph. If we start with nodes and edges, 
we loose information which is readily available in record of stacks.

As we know that we are working with stacks, we know that they have their peculiarities. Stacks tend to grow and shrink. Subsequent events will have extensions and shrinkages of stacks (if the recording is on a fine scale), or stack sharing
common stumps (if the recording is on a coarser scale).


There have  always been interrupts, and these show up in profiles. In \R{}, this is related 
problem  (GC)

The graph is a second instance that is (re)constructed from the stack recording.

Here is the way we represent the profile information:

The profile log file is sanitised:
\begin{itemize}
\item{Control lines are extracted and recorded in a separate list.}
\item{Head parts, if present, ere extracted and recorded in a matrix that is kept line-aligned with the remainder}
\item{Line content is standardised, for example by removing stray quotation marks etc.}
\end{itemize}

After this, the sanitised lines are encoded as a vector of  stacks, and references to this.

If necessary,  these steps are done by chunks to reduce memory load.

From the vector of stacks, a vector of nodes (or rather node names) is derived.

The stacks are now encoded by references to the nodes table.
For convenience, we keep the (sanitised) textual representation of the stacks.

So far, texts are in reverse order. For each stack, we record the trailing leaf, and then we reverse order. 
The top of stack is now on first position.

Several statistics can be accumulated easily as a side effect.

Conceptually, the data structure consist of three tables (the implementation may differ, and is subject to change).

The profiles table is the representation of the input file. Control lines are are collected in a special table. With the control lines removed, the rest is a table, one row per input line. The body of the line, the stack, is encoded as a reference to a stacks table (obligatory) and header information (optional).

The stacks table contains the collected stacks, each stack encoded as a list of references to the node table. This is obligatory. This list is kept in reverse order (root at position 1). A source line representing the stack information may be kept (optional).

The nodes table keeps the names at the nodes.
\todo{18*18}
\subsection{The free lunch}
This is what you get for free when using package \ircode{sprof}:
<<fig=TRUE, label= shownodes02, with=18, heigth=18>>=
shownodes(sprof02)
@
If your want to wrap up the information and look at it from a graph point of view, here is just one example. More are in \vref{sec:graph}. But before changing to the graph perspective, we recommend to see the next sections, not to skip them. The preview, at his point, taking package \ircode{graph} as an example:
<<fig=TRUE, label=sprofadjNEL, width=24, height=24>>=
library(graph)
sprof02adjNEL <- as(adjacency(sprof02),"graphNEL")
plot(sprof02adjNEL,  main="graph layout example", cex.main=2)
rm(sprof02adjNEL); 
# detach("package:graph") 
#! sorry. still needed by Rgraphviz -- clean up
@

\section{xxx}

<< label=tab:prSREinfo>>=
# xtable cannot handle posix
str(sprof01$info,
	caption="splot node info", 
	label="tab:prSREinfo0")
@
As a convention, we do not re-arrange items for ad-hoc choices, but use a permutation 
vector instead. 

<<fig=TRUE, label= barplotNodes>>=
rownames(sprof01$nodes) <- sprof01$nodes$names
nodesperm <- order(sprof01$nodes$total.time,decreasing=TRUE)
barplot(sprof01$nodes$total.time[nodesperm])
@
Selections are recorded as selection vectors, with reference to the original order.
This needs some caution to align them with the order choices.
<<fig=TRUE, label= barplotNodes4>>=
nodesnrobsok <- sprof01$nodes$total.time > 4
sp <- sprof01$nodes$total.time[nodesperm][nodesnrobsok[nodesperm]]
names(sp) <- sprof01$nodes$name[nodesperm][nodesnrobsok[nodesperm]]
barplot(sp,
 main="Nodes, by total time", ylab="total time")
@
<<fig=TRUE, label= barplotStacks>>=
#rownames(sprof01$nodes) <- sprof01$nodes$names
stacksperm <- order(sprof01$stacks$refcount,decreasing=TRUE)
barplot(sprof01$stacks$refcount[stacksperm],main="Stacks, by reference count", ylab="count")

@
<<fig=TRUE, label= barplotStacks4>>=
stacksnrobsok <- sprof01$stacks$refcount > 4
sp4 <- sprof01$stacks$refcount[stacksperm][stacksnrobsok[stacksperm]]

names(sp4) <- sprof01$stacks$shortname[stacksperm][stacksnrobsok[stacksperm]]
barplot(sp4,
 main="Stacks, by reference count (4 obs. minimum)", ylab="count > 4")
@
On the first look, information on the profile level is not informative. Profile records are just recordings of some step, taken at regular intervals. We get a minimal information, if we encode the stacks in colour.
<<fig=TRUE, label=sREplotprofiles242, width=12, height=12>>=
oldpar<-par(mfrow=c(2,2))
plot_profiles(sprof01)
par(oldpar)
@
We now do a step down analysis. Aggregating the information from the profiling events, we have the frequency of stack references. On the stack level, we encode the frequency in colour, and  linking propagates this to the profile level.
<<fig=TRUE, label=sREplotstacks4col>>=
stackfreqscore <- rank(sprof01$stacks$refcount,ties.method="random")
stackfreqscore4<- stackfreqscore[stacksperm][stacksnrobsok[stacksperm]]
barplot(sp[stacksnrobsok[stacksperm]], main="Stacks, by reference count (4 obs. minimum)", ylab="count > 4",
col=rainbow(80)[stackfreqscore4])
@
<<fig=TRUE, label=sREplotprofiles4, width=12, height=12>>=
oldpar<- par(mfrow=c(2,2))
plot_profiles(sprof01)
par(oldpar)
@
%<<>>=
%nodesnrobsok <- sprof01$nodes$total.time > 4
%sp1 <- as.matrix(sprof01$nodes$total.time)
%rownames(sp1) <- sprof01$nodes$name
%sp1 <-  as.matrix(sp1[nodesperm])
%rownames(sp1) <- sprof01$nodes$name[nodesperm]
%sp1 <- as.matrix(sp1[nodesnrobsok[nodesperm]])
%rownames(sp1)<- sprof01$nodes$name[nodesnrobsok[nodesperm]]
%barplot(t(sp1))
@
\filledpagebreak

<<print = FALSE, results = tex, label=tab:prSREnodes>>=
prxt(sprof01$nodes,
	caption="nodes", 
	label="tab:prSREnodes")
@
%<<print = FALSE, results = tex, label=tab:prSREstacks>>=
%prxt(sprof01$stacks,
%	caption="stacks", 
%	label="tab:prSREstacks")
\filledpagebreak
<<label=tab:prSREstacks>>=
str(sprof01$stacks, max.level=1)

<<>>=
str(sprof01$profiles, max.level=1)

@
A summary is provided on request.
<<label=sumsprof01>>=
sumsprof01 <- summary.sprof(sprof01)
str(sumsprof01, max.level=2)
@

The classical approach hides the work that has been done. Actually it breaks down the data to record items. This figure is not reported anywhere. In our case, it can be reconstructed. The profile data have 8456 words in 524 lines.

In our approach, we break down the information. Two lines of control information are split off. We have 522 lines of profile with 50 unique stacks, referencing 62 nodes. Instead of reducing it to a summary, we keep the full information. Information is always kept on its original level. 

On the profiles level, we know the sample interval length, and the id of the stack recorded. On the stack level, for  each stack we have a reference count, with the sample interval lengths used as weights. This reference count is added up for each node in the stack to give the node timings.

Cheap statistics are collected as the come by. For example, from the stacks table it is cheap to identify root and leaf nodes, and this mark is propagated to the nodes table.

\section{Surgery}
Looking at nodes gives you a pointwise horizon. Looking at edges gives you a one step horizon. The stacks give a wider horizon, typically a step size of 10 or more. The stacks we get from \R{} have peculiarities, and we can handle with this broader perspective. These are not relevant if we look pointwise, but may become dominating if we try to get a global picture. We take a look ahead (details to come in \vref{sec:graph} and nave a preview how our example is represented as a graph. Left is the original graph es recovered from the edge information,  right the graph after we have cut off the scaffold effects.
@
\filledpagebreak
\subsection{graph Package}
<<fig=TRUE, label=sprofadj01NEL, width=24, height=12>>=
oldpar <- par(mfrow=c(1,2))
library(graph)
plot(as(adjacency(sprof01),"graphNEL"),  main="graph layout sprof01", cex.main=2)
plot(as(adjacency(sprof02),"graphNEL"),  main="graph layout sprof02", cex.main=2)
par(oldpar)
@
\R{} ist function based, and control structures in general are implemented as functions. In a graph representation, they appear as nodes, concentrating and seeding to unrelated paths. We can detect these on the stack level and replace them by surrogates, introducing new nodes.
\todo{implement}
<<>>=
newchopnode <- function(nodenames, chop) {
tmpname <- paste("<",as.character(nodenames[chop]),">")
# chec for existing.
# add if necessary
tmpname
}
chopstack <- function(x , chop, replacement) 
{
# is chop in x`
# y: cut x.
# merge x <- head + replacement + tiail
return(x)
}
@
\subsection{Apply \& Co}
Control structures may be represented in \R{} as function, and these may lead to concentration points. Using information from the stacks, we can avoid these by introducing substitute nodes on the stack level. For example,

\ircode{"[" "lapply" ".getXlevels"  -> "<.getXlevels\_[>"}

abc

\ircode{"as.list" "vapply" "model.frame.default" -> "<model\_as.list>"}

abc


\ircode{"as.list" "vapply" "model.matrix.default" -> "<model\_matrix\_as.list>"}

abc

@
\todo{fix null name}
<<>>=
sprof03 <- readRprof("RprofsRegressionExpl03.out")
#sprof03$nodes$name[1] <-  sprof03$nodes$name[2]
#sprof03$nodes$name[1]<-"<noop>"??
@
<<fig=TRUE, label=sprofadj03NEL, width=24, height=12>>=
library(graph)
a03<-adjacency(sprof03)
rnames <- rownames(a03)
rnames[1]<-"noop";rownames(a03) <- rnames; colnames(a03) <- rnames; 
plot(as(a03,"graphNEL"),  main="graph layout sprof01", cex.main=2)
@
\section{yyy}
\subsubsection{Plot}
Looking at lists of numbers is not too informative. We get a first impression by plotting the data. 

<<fig=TRUE, label=sREplotnodes, width=12, height=12>>=

#plot_nodes(sprof01, col=nodescol[nodescore])
oldpar <- par(mfrow=c(2,2))
plot_nodes(sprof01)
par(oldpar)
@
%<<fig=TRUE, label=sREplotnodes>>=
%
%nodescore <- 
% (sprof01$nodes$total.time * 
% sprof01$info$nrnodes) %/% max(sprof01$nodes$total.time)
%nodescol <- terrain.colors(sprof01$info$nrnodes)
%sprof01$nodes <- cbind(sprof01$nodes,nodescore,nodescol[nodescore])
%
%plot_nodes(sprof01, col=nodescol[nodescore])
<<fig=TRUE, label=sREplotstacks, width=12, height=6>>=
oldpar <- par(mfrow=c(1,2))
plot_stacks(sprof01)
par(oldpar)

<<fig=TRUE, label=sREplotprofiles323, width=12, height=12>>=
oldpar <-par(mfrow=c(2,2))
plot_profiles(sprof01)
par(oldpar)
@
The \irfunx{misc}{plot} method for \ircode{sprof} objects concatenates these three functions.
\subsection{analysis}
<<>>=
profile_nodes_rrle <- rrle(profile_nodes)
str(profile_nodes_rrle)
@
\subsection{trimming}

<<>>=
trimstacks <- function(sprof, level){
lapply(sprof$stacks$nodes, function(x) {x[-(1:level)]})
}
@
%<<fig=TRUE, label=sREimgprofilesTr>>=
<<label=sREimgprofilesTr>>=
sprof01Tr <- trimstacks(sprof01, 11)
#profile_nodesTr <- profiles_matrix(sprof01Tr)
#image(x=1:ncol(profile_nodesTr),y=1:nrow(profile_nodesTr), t(profile_nodesTr),xlab="event", ylab="depth", main="nodes by event")


<<>>=
nodefreq <- rep(0,length(sprof01$nodes$name))
for (i in (1:length(sprof01$stacks$nodes))){
	nodefreq <- nodefreq +   
		table( factor(sprof01$stacks$nodes[[i]], 
			levels <- 1:length(sprof01$nodes$name), 
			ordered=FALSE))
	}
names(nodefreq) <- sprof01$nodes$name
@
Top frequent nodes.
<<fig=TRUE, label=sREplotnodefreq>>=
ndf <- nodefreq[nodefreq>1]
ondf <- order(ndf,decreasing=TRUE)
barplot(ndf[ondf])
<<fig=TRUE, label=sREplotnodefreq1>>=
barplot(ndf[ondf], col=rainbow(length(ondf)))
@ 
Top frequent stacks.
<<fig=TRUE, label=sREplotstackfreq>>=
x <- sprof01
xsrc <- as.matrix(x$stacks$refcount)
rownames(xsrc) <- rownames(xsrc, do.NULL=FALSE, prefix="S")
#stf <- x$stacks$refcount[x$stacks$refcount>1]
#names(stf) <-  x$stacks$shortname[x$stacks$refcount>1]
stf <- xsrc[xsrc>1]
names(stf) <- rownames(xsrc)[xsrc>1]
ostf <- order(stf,decreasing=TRUE)
barplot(stf[ostf])
<<fig=TRUE, label=sREplotstackfreq1>>=
barplot(stf[ostf], col=terrain.colors(length(ostf)), horiz=TRUE)
<<fig=TRUE, label=sREplotstackfreq2>>=
barplot(stf[ostf], col=terrain.colors(length(ostf)))
@
There is no statistics on profiles. Profiling are our elementary data.
However we can link to our derived data to get a more informative display.
For example, going one step back we can encode stacks and use these colour codes in the display of a profile.

Or going two steps back, we can encode nodes in colour, giving coloured stacks, and use these in the display of profile data.

\section{Standard output}

For a reference, here are complete outputs of the standard function.

<<>>=
sprof <- sprof01
@
\subsection{Print}
<<label=rpoprintnodes>>=
print_nodes(sprof)
<<label=rpoprintstacks>>=
print_stacks(sprof)
<<label=rpoprintprofiles>>=
print_profiles(sprof)
@
The \irfunx{misc}{print} method for \ircode{sprof} objects concatenates these three functions.

\subsection{Summary}
<<label=rposumnodes>>=
summary_nodes(sprof)
<<label=rposumstacks>>=
summary_stacks(sprof)
<<label=rposumprofiles>>=
summary_profiles(sprof)
@
The \irfunx{misc}{summary} method for \ircode{sprof} objects concatenates these three functions.

\filledpagebreak
\subsection{Plot}
<<fig=TRUE, label=rpoplotnodes, width=12, height=12>>=
oldpar<- par(mfrow=c(2,2))
plot_nodes(sprof)
par(oldpar)
@
\filledpagebreak
<<fig=TRUE, label=rpoplotstacks, width=12, height=6>>=
oldpar<- par(mfrow=c(1,2))
plot_stacks(sprof)
par(oldpar)
@
\filledpagebreak
<<fig=TRUE, label=rpoplotprofiles, width=12, height=12>>=
oldpar<- par(mfrow=c(2,2))
plot_profiles(sprof)
par(oldpar)
@
The \irfunx{misc}{plot} method for \ircode{sprof} objects concatenates these three functions.
\filledpagebreak

\section{Graph}
\label{sec:graph}
%Packages used to run examples or
%tests conditionally (e.g. via if(require(pkgname))) should be listed in ÔSuggestsÕ or
%ÔEnhancesÕ.
In this section, we use the recent version of our example, \ircode{sprof02} for demonstration.
You can re-run it, using your  \ircode{sprof} data by modifying this instruction:

<<>>=
sprof <- sprof02
@
To interface \ircode{sprof} to a graph handling package,  \irfunx{adjacency}{until} can extract the adjacency matrix from the profile.

There are various packages for finding a graph layout, and the choice is open to your preferences.  The \R{} packages for most of these are just wrapper



<<>>=
sprofadj <- adjacency(sprof)
@
This is  a format any graph package can handle (maybe).
@
\filledpagebreak
\subsection{graph Package}
<<>>=
library(graph)
sprofadjNEL <- as(sprofadj,"graphNEL")
<<fig=TRUE, label=sprofadjNEL, width=24, height=24>>=
plot(sprofadjNEL,  main="graph layout", cex.main=2)
#detach("package:graph")
@
\filledpagebreak
\subsubsection{igraph Package}
<<>>=
library(igraph)
sprofig <- graph.adjacency(sprofadj)
<<fig=TRUE, label=sprofig, width=24, height=24>>=
#plot(sprofig, main="igraph layout", cex.main=5)
plot(sprofig, main="igraph layout")

detach("package:igraph")
@
\filledpagebreak
\subsubsection{network Package}
<<fig=TRUE, label=nwsprofadj, width=24, height=24>>=
library(network)
nwsprofadj <- as.network(sprofadj) # names is not imported 
network.vertex.names(nwsprofadj) <- rownames(sprofadj) # not honoured by plot
plot(nwsprofadj, label=rownames(sprofadj), main="network layout", cex.main=5)

<<fig=TRUE, label=nwsprofadje, width=24, height=24>>=

edge.lwd <- trunc(sprofadj/max(sprofadj)*10)+1
plot(nwsprofadj, label=rownames(sprofadj), main="network layout", cex.main=2, edge.lwd=edge.lwd)
detach("package:network")
@
\filledpagebreak
\subsubsection{Rgraphviz Package}
<<>>=
library(Rgraphviz)
sprofadjRag <- agopen(sprofadjNEL, name="Rprof Example")
<<fig=TRUE, label=sprofadjvizdot, width=24, height=24>>=
plot(sprofadjRag, main="Graphviz dot layout", cex.main=5)
@
%agopen(graph, name, nodes, edges, kind = NULL, layout = TRUE,
%layoutType = "dot",
%attrs = list(), nodeAttrs = list(), edgeAttrs = list(),
%subGList = list(), edgeMode = edgemode(graph),
%recipEdges=c("combined", "distinct"))

%dot, neato, twopi, circo, and fdp.
\filledpagebreak
<<fig=TRUE, label=sprofadjvizneato, width=24, height=24>>=
plot(sprofadjRag,"neato", main="Graphviz neto layout", cex.main=5)
@
\filledpagebreak
<<fig=TRUE, label=sprofadjviztwopi, width=24, height=24>>=
plot(sprofadjRag,"twopi", main="Graphviz twopi layout", cex.main=5)
@
\filledpagebreak
<<fig=TRUE, label=sprofadjvizcirco, width=24, height=24>>=
plot(sprofadjRag,"circo", main="Graphviz circo layout", cex.main=5)
@
\filledpagebreak
<<fig=TRUE, label=sprofadjvizfdp, width=24, height=24>>=
plot(sprofadjRag,"fdp", main="Graphviz fdp layout", cex.main=5)
@
\section{Graph II}
\label{sec:graph}
%Packages used to run examples or
%tests conditionally (e.g. via if(require(pkgname))) should be listed in ÔSuggestsÕ or
%ÔEnhancesÕ.
In this section, we use the reduced version of our example, \ircode{sprof03} for demonstration. Except for the change of the data set, this is just a copy of the previous chapter, collecting the various layouts for easy reference.

You can re-run it, using your  \ircode{sprof} data by modifying this instruction:

<<>>=
sprof <- sprof03
@
To interface \ircode{sprof} to a graph handling package,  \irfunx{adjacency}{until} can extract the adjacency matrix from the profile.

<<>>=
sprofadj <- adjacency(sprof)
adjname <- colnames(sprofadj)
adjname[adjname==""] <- "<NULL>"
 colnames(sprofadj) <- adjname
 rownames(sprofadj) <- adjname
@
This is  a format any graph package can handle (maybe).
@
\filledpagebreak
\subsection{graph Package}
<<>>=
library(graph)
sprofadjNEL <- as(sprofadj,"graphNEL")
<<fig=TRUE, label=sprofadjNEL, width=24, height=24>>=
plot(sprofadjNEL,  main="graph layout", cex.main=2)
#detach("package:graph")
@
\filledpagebreak
\subsubsection{igraph Package}
<<>>=
library(igraph)
sprofig <- graph.adjacency(sprofadj)
<<fig=TRUE, label=sprofig, width=24, height=24>>=
#plot(sprofig, main="igraph layout", cex.main=5)
plot(sprofig, main="igraph layout")

detach("package:igraph")
@
\filledpagebreak
\subsubsection{network Package}
<<fig=TRUE, label=nwsprofadj, width=24, height=24>>=
library(network)
nwsprofadj <- as.network(sprofadj) # names is not imported 
network.vertex.names(nwsprofadj) <- rownames(sprofadj) # not honoured by plot
plot(nwsprofadj, label=rownames(sprofadj), main="network layout", cex.main=5)

<<fig=TRUE, label=nwsprofadje, width=24, height=24>>=

edge.lwd <- trunc(sprofadj/max(sprofadj)*10)+1
plot(nwsprofadj, label=rownames(sprofadj), main="network layout", cex.main=2, edge.lwd=edge.lwd)
detach("package:network")
@
\filledpagebreak
\subsubsection{Rgraphviz Package}
<<>>=
library(Rgraphviz)
sprofadjRag <- agopen(sprofadjNEL, name="Rprof Example")
<<fig=TRUE, label=sprofadjvizdot, width=24, height=24>>=
plot(sprofadjRag, main="Graphviz dot layout", cex.main=5)
@
%agopen(graph, name, nodes, edges, kind = NULL, layout = TRUE,
%layoutType = "dot",
%attrs = list(), nodeAttrs = list(), edgeAttrs = list(),
%subGList = list(), edgeMode = edgemode(graph),
%recipEdges=c("combined", "distinct"))

%dot, neato, twopi, circo, and fdp.
\filledpagebreak
<<fig=TRUE, label=sprofadjvizneato, width=24, height=24>>=
plot(sprofadjRag,"neato", main="Graphviz neto layout", cex.main=5)
@
\filledpagebreak
<<fig=TRUE, label=sprofadjviztwopi, width=24, height=24>>=
plot(sprofadjRag,"twopi", main="Graphviz twopi layout", cex.main=5)
@
\filledpagebreak
<<fig=TRUE, label=sprofadjvizcirco, width=24, height=24>>=
plot(sprofadjRag,"circo", main="Graphviz circo layout", cex.main=5)
@
\filledpagebreak
<<fig=TRUE, label=sprofadjvizfdp, width=24, height=24>>=
plot(sprofadjRag,"fdp", main="Graphviz fdp layout", cex.main=5)
@
\index{Index01}
%:Sweave examples
%<<print=TRUE>>=
%<<results=hide>>=
%@
%<<echo=TRUE,print=TRUE>>=
%<<>>=
%@
%%\texttt{x} is 6.28318530717959, the
%<<engine=R>>=
%@ %def
%\begin{figure}[htbp]
%  \begin{center}
%<<fig=TRUE>>=
%@
%    \caption{.}
%  \end{center}
%\end{figure}
%<<engine=S4>>=
%@
\bigskip%\cleardoublepage
\printindex
\bigskip
\R{} session info:

<<echo=FALSE,  print = FALSE, results = tex>>=
toLatex(sessionInfo())
@
svn repository info:

{\tiny%
%	<<echo = FALSE, print = FALSE, results = tex>>= 
%	cat("Generated by Sweave from:\\\\")
%	cat(chartr("$", " ", "\\verb+$Source: /u/math/j40/cvsroot/lectures/src/insider/profile/Rnw/profile.Rnw,v $+\\\\"))
%	cat(chartr("$", " ", "\\verb+$Revision$+\\\\"))
%	cat(chartr("$", " ", "\\verb+$Date$+\\\\"))
%	cat(chartr("$", " ", "\\verb+$name:  $+\\\\"))
%	cat(chartr("$", " ", "\\verb+$Author$+\\\\"))
%	@
\noindent
\verb+$HeadURL$+\\
\verb+$Source: /u/math/j40/cvsroot/lectures/src/insider/profile/Rnw/profile.Rnw,v $+\\
\verb+$Id$+\\
\verb+$Revision$+\\
\verb+$Date$+\\
\verb+$name:  $+\\
\verb+$Author$+
}
\typeout{**** $Id$ done ****}
\end{document}


